// Generated by CoffeeScript 1.7.1
(function() {
  var Entry, EventEmitter, Packet, caesar, config, crypto, getProofNumber, sjcl,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  crypto = require('crypto');

  config = require('config');

  EventEmitter = require('events').EventEmitter;

  sjcl = require('./sjcl');

  caesar = {
    kts: require('./caesar/kts'),
    hash: require('./caesar/hash'),
    tree: require('./caesar/tree')
  };

  config.sead.j = Math.log(config.sead.n + 1) / Math.log(2);

  config.sead.x = 565 + (42 * config.sead.j);

  config.sead.y = 49 + config.sead.x;

  getProofNumber = function(proof) {
    var line, num, _i, _len;
    num = '';
    for (_i = 0, _len = proof.length; _i < _len; _i++) {
      line = proof[_i];
      num = (1 - line[0]) + num;
    }
    num = parseInt(num, 2);
    return num;
  };

  Packet = (function() {
    function Packet(boxed) {
      this.boxed = boxed;
      this.__defineGetter__('type', function() {
        var type;
        type = this.boxed.readUInt8(0);
        if (type === 0 && this.boxed.length === 49) {
          return 'id';
        }
        if (type === 1 && this.boxed.length >= 49) {
          return 'data';
        }
        if (type === 2 && this.boxed.length === config.sead.y) {
          return 'update';
        }
        return 'bad';
      });
      this.__defineSetter__('type', function(type) {
        if (type === 'id') {
          this.boxed = new Buffer(49);
          return this.boxed.fill(0);
        } else if (type === 'data') {
          this.boxed = new Buffer(49);
          this.boxed.fill(0);
          return this.boxed.writeUInt8(1, 0);
        } else if (type === 'update') {
          this.boxed = new Buffer(config.sead.y);
          this.boxed.fill(0);
          return this.boxed.writeUInt8(2, 0);
        } else {
          return false;
        }
      });
      this.__defineGetter__('id', function() {
        if (this.type === 'id' || this.type === 'update') {
          return this.boxed.slice(1, 49).toString('base64');
        } else {
          return null;
        }
      });
      this.__defineSetter__('id', function(id) {
        if (this.type === 'id' || this.type === 'update') {
          return this.boxed.write(id, 1, 48, 'base64');
        } else {
          return null;
        }
      });
      this.__defineGetter__('to', function() {
        if (this.type === 'data') {
          return this.boxed.slice(1, 49).toString('base64');
        } else {
          return null;
        }
      });
      this.__defineSetter__('to', function(to) {
        if (this.type === 'data') {
          return this.boxed.write(to, 1, 48, 'base64');
        } else {
          return null;
        }
      });
      this.__defineGetter__('cargo', function() {
        if (this.type === 'data' || this.type === 'update') {
          return this.boxed.slice(49);
        } else {
          return null;
        }
      });
      this.__defineSetter__('cargo', function(cargo) {
        if (this.type === 'data' || this.type === 'update') {
          cargo = new Buffer(cargo);
          return this.boxed = Buffer.concat([this.boxed.slice(0, 49), cargo]);
        } else {
          return null;
        }
      });
    }

    return Packet;

  })();

  Entry = (function() {
    function Entry(entry) {
      this.boxed = new Buffer(config.sead.x);
      this.boxed.fill(0);
      this.__defineGetter__('metric', function() {
        var m;
        m = this.boxed.readUInt8(0);
        if (m === 255) {
          return Infinity;
        } else {
          return m;
        }
      });
      this.__defineSetter__('metric', function(metric) {
        if (metric === Infinity) {
          metric = 255;
        }
        return this.boxed.writeUInt8(metric, 0);
      });
      this.__defineGetter__('next', function() {
        return this.boxed.slice(1, 49).toString('base64');
      });
      this.__defineSetter__('next', function(next) {
        return this.boxed.write(next, 1, 48, 'base64');
      });
      this.__defineGetter__('sq', function() {
        return this.boxed.readUInt32BE(49);
      });
      this.__defineSetter__('sq', function(sq) {
        return this.boxed.writeUInt32BE(sq, 49);
      });
      this.__defineGetter__('element', function() {
        return this.boxed.slice(53, 73).toString('hex');
      });
      this.__defineSetter__('element', function(el) {
        return this.boxed.write(el, 53, 20, 'hex');
      });
      this.__defineGetter__('timestamp', function() {
        return this.boxed.readUInt32BE(73);
      });
      this.__defineSetter__('timestamp', function(ts) {
        return this.boxed.writeUInt32BE(ts, 73);
      });
      this.__defineGetter__('signature', function() {
        return this.boxed.slice(77, 125).toString('base64');
      });
      this.__defineSetter__('signature', function(signature) {
        return this.boxed.write(signature, 77, 48, 'base64');
      });
      this.__defineGetter__('proof', function() {
        var c, i, p, proof, _ref;
        _ref = [125, 0, []], c = _ref[0], i = _ref[1], proof = _ref[2];
        while (i !== config.sead.j) {
          p = [];
          p[0] = this.boxed.readUInt8(c);
          p[1] = this.boxed.slice(c + 1, c + 21).toString('hex');
          proof.push(p);
          c += 21;
          ++i;
        }
        return proof;
      });
      this.__defineSetter__('proof', function(proof) {
        var c, part, _i, _len, _results;
        c = 125;
        _results = [];
        for (_i = 0, _len = proof.length; _i < _len; _i++) {
          part = proof[_i];
          this.boxed.writeUInt8(part[0], c);
          this.boxed.write(part[1], c + 1, 20, 'hex');
          _results.push(c += 21);
        }
        return _results;
      });
      this.__defineGetter__('verification', function() {
        var c, i, p, verification, _ref;
        _ref = [0, [[], []]], i = _ref[0], verification = _ref[1];
        c = 125 + (21 * config.sead.j);
        while (i !== 22) {
          verification[0].push(this.boxed.slice(c, c + 20).toString('hex'));
          c += 20;
          ++i;
        }
        i = 0;
        while (i !== config.sead.j) {
          p = [];
          p[0] = this.boxed.readUInt8(c);
          p[1] = this.boxed.slice(c + 1, c + 21).toString('hex');
          verification[1].push(p);
          c += 21;
          ++i;
        }
        return verification;
      });
      this.__defineSetter__('verification', function(verification) {
        var c, part, _i, _j, _len, _len1, _ref, _ref1, _results;
        c = 125 + (21 * config.sead.j);
        _ref = verification[0];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          part = _ref[_i];
          this.boxed.write(part, c, 20, 'hex');
          c += 20;
        }
        _ref1 = verification[1];
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          part = _ref1[_j];
          this.boxed.writeUInt8(part[0], c);
          this.boxed.write(part[1], c + 1, 20, 'hex');
          _results.push(c += 21);
        }
        return _results;
      });
      if (entry == null) {
        return;
      }
      this.metric = entry.metric;
      if (entry.next != null) {
        this.next = entry.next;
      }
      this.sq = entry.sq;
      this.element = entry.element;
      this.signature = entry.signature;
      this.proof = entry.proof;
      if (entry.verification != null) {
        this.verification = entry.verification;
      }
      this.timestamp = entry.timestamp;
    }

    return Entry;

  })();

  exports.Router = (function(_super) {
    __extends(Router, _super);

    function Router(time) {
      var c, clean, run, x, y;
      this.time = time;
      x = config.sead.timeouts.interval * config.sead.n;
      y = config.sead.m * config.sead.period;
      this.ttl = Math.max(x, y) + config.sead.timeouts.grace;
      this.ttl = Math.floor(this.ttl / 1000);
      c = sjcl.ecc.curves.c192;
      this.keys = {
        elGamal: sjcl.ecc.elGamal.generateKeys(c)
      };
      this.keys.ecdsa = {
        pub: this.keys.elGamal.pub.get(),
        sec: this.keys.elGamal.sec.get()
      };
      this.keys.ecdsa.pub = new sjcl.ecc.ecdsa.publicKey(c, sjcl.codec.hex.toBits(sjcl.codec.hex.fromBits(this.keys.ecdsa.pub.x) + sjcl.codec.hex.fromBits(this.keys.ecdsa.pub.y)));
      this.keys.ecdsa.sec = new sjcl.ecc.ecdsa.secretKey(c, sjcl.bn.fromBits(this.keys.ecdsa.sec));
      this.id = sjcl.codec.hex.fromBits(this.keys.elGamal.pub.get().x);
      this.id += sjcl.codec.hex.fromBits(this.keys.elGamal.pub.get().y);
      this.id = sjcl.codec.base64.fromBits(sjcl.codec.hex.toBits(this.id));
      this.conns = {};
      this.table = {};
      this.cache = {};
      setInterval(this.network, config.sead.period, this.conns, this.table);
      run = (function(_this) {
        return function() {
          if (_this.table[_this.id] != null) {
            return _this.configure();
          }
        };
      })(this);
      setInterval(run, config.sead.timeouts.interval);
      clean = (function(_this) {
        return function() {
          var entry, id, _ref, _results;
          _ref = _this.table;
          _results = [];
          for (id in _ref) {
            entry = _ref[id];
            if ((_this.time.get() - entry.timestamp) > _this.ttl) {
              _results.push(delete _this.table[id]);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
      })(this);
      setInterval(clean, config.sead.timeouts.cleanup);
    }

    Router.prototype.configure = function() {
      var anchors, commit, first, msg, oldProof, proof, sig, signer, sq, ts, tsStr, val, ver;
      sq = this.table[this.id] != null ? this.table[this.id].sq + 1 : 0;
      if (sq % config.sead.n === 0) {
        signer = new caesar.kts.Signer(1);
        this.oldSecret = this.secret;
        this.secret = signer.getPrivateKey()[1];
        anchors = [];
        while (anchors.length !== config.sead.n) {
          val = this.secret + ':' + anchors.length;
          anchors.push(caesar.hash.chain(val, config.sead.m + 1, 'sha1'));
        }
        anchors.push(signer.getPublicKey());
        this.oldCommitter = this.committer;
        this.committer = new caesar.tree.Committer(anchors, 'sha1');
        commit = this.committer.getCommit();
        proof = this.committer.getProof(0);
        ts = time.get();
        tsStr = ts.toString();
        if (this.oldSecret != null) {
          signer = new caesar.kts.Signer(1, this.oldSecret);
          msg = Math.floor(sq / config.sead.n).toString() + commit + tsStr;
          sig = signer.sign(msg);
          oldProof = this.oldCommitter.getProof(config.sead.n);
          ver = [sig, oldProof];
        } else {
          ver = null;
        }
        sig = Math.floor(sq / config.sead.n).toString() + commit + tsStr;
        sig = this.keys.ecdsa.sec.sign(sjcl.hash.sha256.hash(sig));
        sig = sjcl.codec.base64.fromBits(sig);
        first = caesar.hash.chain(this.secret + ':0', 1, 'sha1');
        return this.table[this.id] = new Entry({
          metric: 0,
          next: null,
          sq: sq,
          element: first,
          proof: proof,
          verification: ver,
          signature: sig,
          timestamp: ts
        });
      } else {
        val = this.secret + ':' + (sq % config.sead.n);
        first = caesar.hash.chain(val, 1, 'sha1');
        this.table[this.id].sq = sq;
        this.table[this.id].proof = this.committer.getProof(sq % config.sead.n);
        return this.table[this.id].element = first;
      }
    };

    Router.prototype.feed = function(conn, fn) {
      var close, packet, tid;
      close = function(conn, fn) {
        conn.end();
        if (fn != null) {
          return fn(false);
        }
      };
      tid = setTimeout(close, 5000, conn, fn);
      conn.on('data', (function(_this) {
        return function(data) {
          var c, err, id, key, pubKey;
          data = new Packet(data);
          if (data.type === 'id') {
            try {
              c = sjcl.ecc.curves.c192;
              pubKey = new sjcl.ecc.elGamal.publicKey(c, sjcl.codec.base64.toBits(data.id));
              key = _this.keys.elGamal.sec.dh(pubKey);
              key = sjcl.misc.pbkdf2(key, config.sead.pbkdf.salt, config.sead.pbkdf.count, 256);
              key = sjcl.codec.hex.fromBits(key);
              clearTimeout(tid);
              id = data.id;
              _this.conns[id] = conn;
              _this.conns[id].key = key;
              _this.configure();
              _this.conns[id]._expectedLen = 0;
              _this.conns[id]._store = new Buffer(0);
              conn.removeAllListeners('data');
              _this.conns[id].on('data', function(data) {
                var candidateHmac, excess, hmac, mlen, tmp;
                if (_this.conns[id]._store.length !== 0) {
                  tmp = [_this.conns[id]._store, data];
                  _this.conns[id]._store = Buffer.concat(tmp);
                  if (_this.conns[id]._store >= _this.conns[id]._expectedLen) {
                    data = _this.conns[id]._store;
                    if (data.length > _this.conns[id]._expectedLen) {
                      excess = data.slice(_this.conns[id]._expectedLen);
                      data = data.slice(0, _this.conns[id]._expectedLen);
                      _this.conns[id].emit('data', excess);
                    }
                    _this.conns[id]._expectedLen = 0;
                    _this.conns[id]._store = new Buffer(0);
                  } else {
                    return;
                  }
                } else {
                  mlen = data.readUInt16BE(0);
                  if (mlen === 0) {
                    return;
                  }
                  data = data.slice(2);
                  if (data.length < mlen) {
                    _this.conns[id]._expectedLen = mlen;
                    _this.conns[id]._store = data;
                    return;
                  } else if (data.length > mlen) {
                    excess = data.slice(mlen);
                    data = data.slice(0, mlen);
                    _this.conns[id].emit('data', excess);
                  }
                }
                candidateHmac = data.slice(data.length - 32);
                candidateHmac = candidateHmac.toString('base64');
                data = data.slice(0, data.length - 32);
                hmac = crypto.createHmac('sha256', _this.conns[id].key);
                hmac.end(data);
                hmac = hmac.read().toString('base64');
                if (candidateHmac !== hmac) {
                  return;
                }
                data = new Packet(data);
                if (data.type === 'data' && data.to === _this.id) {
                  return _this.emit('data', data.cargo);
                } else if (data.type === 'data' && data.to !== _this.id) {
                  return _this.write(data.to, data.cargo);
                } else if (data.type === 'update') {
                  return _this.update(id, data.id, data.cargo);
                }
              });
              _this.conns[id].on('close', function() {
                var _ref;
                if ((_ref = _this.table[id]) != null) {
                  _ref.metric = Infinity;
                }
                return delete _this.conns[id];
              });
              if (fn != null) {
                return fn(null);
              }
            } catch (_error) {
              err = _error;
              if (fn != null) {
                return fn(err);
              }
            }
          }
        };
      })(this));
      conn.on('error', function() {});
      packet = new Packet();
      packet.type = 'id';
      packet.id = this.id;
      return conn.write(packet.boxed);
    };

    Router.prototype.write = function(addr, data, fn) {
      var buff, hmac, packet;
      if ((this.table[addr] != null) && this.table[addr].metric !== Infinity) {
        packet = new Packet();
        packet.type = 'data';
        packet.to = addr;
        packet.cargo = data;
        hmac = crypto.createHmac('sha256', this.conns[this.table[addr].next].key);
        hmac.end(packet.boxed);
        hmac = hmac.read();
        buff = new Buffer(2);
        buff.writeUInt16BE(packet.boxed.length + hmac.length, 0);
        buff = Buffer.concat([buff, packet.boxed, hmac]);
        this.conns[this.table[addr].next].write(buff);
        if (fn != null) {
          return fn(true);
        }
      } else if (fn != null) {
        return fn(false);
      }
    };

    Router.prototype.update = function(sender, id, cargo) {
      var anchor, c, cand, err, fin, h, msg, newItr, num, old, oldItr, pubKey, root, sig, tmp, ver, x, _ref, _ref1;
      if (id === this.id) {
        return;
      }
      cand = new Entry();
      cand.boxed = cargo;
      if (this.table[id] != null) {
        if (cand.timestamp > time.get()) {
          return;
        }
        if ((time.get() - cand.timestamp) > this.ttl) {
          return;
        }
        if (cand.sq < this.table[id].sq) {
          return;
        }
        if (cand.sq === this.table[id].sq && this.table[id].metric === Infinity) {
          return;
        }
        if (cand.sq === this.table[id].sq && (cand.metric + 1) >= this.table[id].metric) {
          return;
        }
      }
      cand.metric = cand.metric + 1;
      cand.next = sender;
      cand.element = caesar.hash.chain(cand.element, 1, 'sha1');
      x = config.sead.m - cand.metric;
      if (x < 0) {
        return;
      }
      anchor = caesar.hash.chain(cand.element, x, 'sha1');
      root = caesar.tree.forward(anchor, cand.proof, 'sha1');
      num = getProofNumber(cand.proof);
      if (num !== (cand.sq % config.sead.n)) {
        return;
      }
      try {
        oldItr = Math.floor(((_ref = this.table[id]) != null ? _ref.sq : void 0) / config.sead.n);
        newItr = Math.floor(cand.sq / config.sead.n);
        if ((this.table[id] != null) && newItr === (oldItr + 1)) {
          if (config.sead.n !== getProofNumber(cand.verification[1])) {
            return;
          }
          ver = new caesar.kts.Verifier();
          msg = newItr + root + cand.timestamp.toString();
          _ref1 = ver.forward(msg, cand.verification[0]), tmp = _ref1[0], fin = _ref1[1];
          old = caesar.tree.forward(fin, cand.verification[1], 'sha1');
          if (old !== this.cache[id]) {
            return;
          }
        } else if ((this.table[id] != null) && newItr === oldItr) {
          if (root !== this.cache[id]) {
            return;
          }
        } else {
          c = sjcl.ecc.curves.c192;
          pubKey = new sjcl.ecc.ecdsa.publicKey(c, sjcl.codec.base64.toBits(id));
          h = Math.floor(cand.sq / config.sead.n).toString() + root;
          h += cand.timestamp.toString();
          h = sjcl.hash.sha256.hash(h);
          sig = sjcl.codec.base64.toBits(cand.signature);
          ver = pubKey.verify(h, sig);
          if (!ver) {
            return;
          }
        }
      } catch (_error) {
        err = _error;
        return;
      }
      this.table[id] = cand;
      this.cache[id] = root;
    };

    Router.prototype.network = function(conns, table) {
      var buff, cargo, conn, hmac, id, packet, peerId, _results;
      _results = [];
      for (id in conns) {
        conn = conns[id];
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (peerId in table) {
            cargo = table[peerId];
            packet = new Packet();
            packet.type = 'update';
            packet.id = peerId;
            packet.cargo = cargo.boxed;
            hmac = crypto.createHmac('sha256', conn.key);
            hmac.end(packet.boxed);
            hmac = hmac.read();
            buff = new Buffer(2);
            buff.writeUInt16BE(packet.boxed.length + hmac.length, 0);
            buff = Buffer.concat([buff, packet.boxed, hmac]);
            _results1.push(conn.write(buff));
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Router;

  })(EventEmitter);

}).call(this);
